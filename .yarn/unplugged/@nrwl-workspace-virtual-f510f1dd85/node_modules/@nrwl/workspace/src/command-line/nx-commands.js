"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commandsObject = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const chalk = require("chalk");
const child_process_1 = require("child_process");
const path = require("path");
const yargs = require("yargs");
const generate_help_output_1 = require("../core/project-graph/daemon/client/generate-help-output");
const versions_1 = require("../utils/versions");
const examples_1 = require("./examples");
const app_root_1 = require("nx/src/utils/app-root");
const noop = (yargs) => yargs;
const isGenerateDocsProcess = process.env.NX_GENERATE_DOCS_PROCESS === 'true';
const daemonHelpOutput = (0, generate_help_output_1.generateDaemonHelpOutput)(isGenerateDocsProcess);
// Ensure that the output takes up the available width of the terminal
yargs.wrap(yargs.terminalWidth());
/**
 * Exposing the Yargs commands object so the documentation generator can
 * parse it. The CLI will consume it and call the `.argv` to bootstrapped
 * the CLI. These command declarations needs to be in a different file
 * from the `.argv` call, so the object and it's relative scripts can
 * be executed correctly.
 */
exports.commandsObject = yargs
    .parserConfiguration({
    'strip-dashed': true,
})
    .usage(`
${chalk.bold('Smart, Fast and Extensible Build System')}` +
    (daemonHelpOutput
        ? `

${daemonHelpOutput}
  `.trimRight()
        : ''))
    .command('run [project][:target][:configuration] [options, ...]', `
    Run a target for a project
    (e.g., nx run myapp:serve:production).

    You can also use the infix notation to run a target:
    (e.g., nx serve myapp --configuration=production)

    You can skip the use of Nx cache by using the --skip-nx-cache option.
    `)
    .command('generate [collection:][generator] [options, ...]', `
    ${chalk.bold('Generate or update source code')}
    (e.g., nx generate @nrwl/web:app myapp).
    `)
    .command('affected', chalk.bold('Run target for affected projects'), (yargs) => linkToNxDevAndExamples(withAffectedOptions(withParallel(withTarget(yargs))), 'affected'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./affected'))).affected('affected', Object.assign({}, args)); }))
    .command('run-many', chalk.bold('Run target for multiple listed projects'), (yargs) => linkToNxDevAndExamples(withRunManyOptions(withParallel(withTarget(yargs))), 'run-many'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./run-many'))).runMany(Object.assign({}, args)); }))
    .command('affected:apps', chalk.bold('Print applications affected by changes'), (yargs) => linkToNxDevAndExamples(withAffectedOptions(withPlainOption(yargs)), 'affected:apps'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./affected'))).affected('apps', Object.assign({}, args)); }))
    .command('affected:libs', chalk.bold('Print libraries affected by changes'), (yargs) => linkToNxDevAndExamples(withAffectedOptions(withPlainOption(yargs)), 'affected:libs'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    return (yield Promise.resolve().then(() => require('./affected'))).affected('libs', Object.assign({}, args));
}))
    .command('affected:build', chalk.bold('Build applications and publishable libraries affected by changes'), (yargs) => linkToNxDevAndExamples(withAffectedOptions(withParallel(yargs)), 'affected:build'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    return (yield Promise.resolve().then(() => require('./affected'))).affected('affected', Object.assign(Object.assign({}, args), { target: 'build' }));
}))
    .command('affected:test', chalk.bold('Test projects affected by changes'), (yargs) => linkToNxDevAndExamples(withAffectedOptions(withParallel(yargs)), 'affected:test'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    return (yield Promise.resolve().then(() => require('./affected'))).affected('affected', Object.assign(Object.assign({}, args), { target: 'test' }));
}))
    .command('affected:e2e', chalk.bold('Run e2e tests for the applications affected by changes'), (yargs) => linkToNxDevAndExamples(withAffectedOptions(withParallel(yargs)), 'affected:e2e'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    return (yield Promise.resolve().then(() => require('./affected'))).affected('affected', Object.assign(Object.assign({}, args), { target: 'e2e' }));
}))
    .command({
    command: 'affected:graph',
    describe: chalk.bold('Graph dependencies affected by changes. Alias: affected:dep-graph'),
    aliases: ['affected:dep-graph'],
    builder: (yargs) => linkToNxDevAndExamples(withAffectedOptions(withDepGraphOptions(yargs)), 'affected:graph'),
    handler: (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
        return (yield Promise.resolve().then(() => require('./affected'))).affected('graph', Object.assign({}, args));
    }),
})
    .command('print-affected', chalk.bold('Prints information about the projects and targets affected by changes'), (yargs) => linkToNxDevAndExamples(withAffectedOptions(withPrintAffectedOptions(yargs)), 'print-affected'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    return (yield Promise.resolve().then(() => require('./affected'))).affected('print-affected', Object.assign({}, args));
}))
    .command('affected:lint', chalk.bold('Lint projects affected by changes'), (yargs) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    return linkToNxDevAndExamples(withAffectedOptions(withParallel(yargs)), 'affected:lint');
}), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    return (yield Promise.resolve().then(() => require('./affected'))).affected('affected', Object.assign(Object.assign({}, args), { target: 'lint' }));
}))
    .command('daemon', daemonHelpOutput
    ? (0, devkit_1.stripIndents) `${daemonHelpOutput}`.trimRight()
    : `

The Daemon is not currently running you can start it manually by running the following command:

npx nx daemon
`.trimRight(), (yargs) => linkToNxDevAndExamples(withDaemonStartOptions(yargs), 'daemon'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./daemon'))).daemonHandler(args); }))
    .command({
    command: 'graph',
    describe: chalk.bold('Graph dependencies within workspace. Alias: dep-graph'),
    aliases: ['dep-graph'],
    builder: (yargs) => linkToNxDevAndExamples(withDepGraphOptions(yargs), 'dep-graph'),
    handler: (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./dep-graph'))).generateGraph(args, []); }),
})
    .command('format:check', chalk.bold('Check for un-formatted files'), (yargs) => linkToNxDevAndExamples(withFormatOptions(yargs), 'format:check'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./format'))).format('check', args); }))
    .command(['format:write', 'format'], chalk.bold('Overwrite un-formatted files'), (yargs) => linkToNxDevAndExamples(withFormatOptions(yargs), 'format:write'), (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./format'))).format('write', args); }))
    .command('workspace-lint [files..]', chalk.bold('Lint nx specific workspace files (nx.json, workspace.json), checks if your configuration and your source code are in sync. This command identifies projects with no files in the configured project root folder, as well as files that are not part of any projects in the workspace. Note: To exclude files from this lint rule, you can add them to the `.nxignore` file.'), noop, (_) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./lint'))).workspaceLint(); }))
    .command(['workspace-generator [name]', 'workspace-schematic [name]'], chalk.bold('Runs a workspace generator from the tools/generators directory'), (yargs) => {
    yargs.option('list-generators', {
        describe: 'List the available workspace-generators',
        type: 'boolean',
    });
    /**
     * Don't require `name` if only listing available
     * schematics
     */
    if (yargs.argv.listGenerators !== true) {
        yargs.demandOption(['name']).positional('name', {
            type: 'string',
            describe: 'The name of your generator`',
        });
    }
    return linkToNxDevAndExamples(yargs, 'workspace-generator');
}, () => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () {
    return (yield Promise.resolve().then(() => require('./workspace-generators'))).workspaceGenerators(process.argv.slice(3));
}))
    .command('migrate', chalk.bold(`Creates a migrations file or runs migrations from the migrations file.
- Migrate packages and create migrations.json (e.g., nx migrate @nrwl/workspace@latest)
- Run migrations (e.g., nx migrate --run-migrations=migrations.json)
`), (yargs) => linkToNxDevAndExamples(yargs, 'migrate'), () => {
    const runLocalMigrate = () => {
        const pmc = (0, devkit_1.getPackageManagerCommand)();
        (0, child_process_1.execSync)(`${pmc.exec} nx _migrate ${process.argv.slice(3).join(' ')}`, {
            stdio: ['inherit', 'inherit', 'inherit'],
        });
    };
    if (process.env.NX_MIGRATE_USE_LOCAL === undefined) {
        const p = nxCliPath();
        if (p === null) {
            runLocalMigrate();
        }
        else {
            (0, child_process_1.execSync)(`${p} _migrate ${process.argv.slice(3).join(' ')}`, {
                stdio: ['inherit', 'inherit', 'inherit'],
            });
        }
    }
    else {
        runLocalMigrate();
    }
})
    .command(require('./report').report)
    .command({
    command: 'list [plugin]',
    describe: 'Lists installed plugins, capabilities of installed plugins and other available plugins.',
    builder: (yargs) => yargs.positional('plugin', {
        type: 'string',
        description: 'The name of an installed plugin to query',
    }),
    handler: (args) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./list'))).listHandler(args); }),
})
    .command({
    command: 'reset',
    describe: 'Clears all the cached Nx artifacts and metadata about the workspace and shuts down the Nx Daemon.',
    // Prior to v13 clear-cache was a top level nx command, so preserving as an alias
    aliases: ['clear-cache'],
    handler: () => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./reset'))).resetHandler(); }),
})
    .command('connect-to-nx-cloud', chalk.bold(`Makes sure the workspace is connected to Nx Cloud`), (yargs) => linkToNxDevAndExamples(yargs, 'connect-to-nx-cloud'), () => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return (yield Promise.resolve().then(() => require('./connect-to-nx-cloud'))).connectToNxCloudCommand(); }))
    .help('help')
    .version(versions_1.nxVersion);
function withFormatOptions(yargs) {
    return withAffectedOptions(yargs)
        .option('libs-and-apps', {
        describe: 'Format only libraries and applications files.',
        type: 'boolean',
    })
        .option('projects', {
        describe: 'Projects to format (comma delimited)',
        type: 'array',
        coerce: parseCSV,
    })
        .conflicts({
        all: 'projects',
    });
}
function linkToNxDevAndExamples(yargs, command) {
    (examples_1.examples[command] || []).forEach((t) => {
        yargs = yargs.example(t.command, t.description);
    });
    return yargs.epilog(chalk.bold(`Find more information and examples at https://nx.dev/cli/${command.replace(':', '-')}`));
}
function withDaemonStartOptions(yargs) {
    return yargs.option('background', { type: 'boolean', default: true });
}
function withPrintAffectedOptions(yargs) {
    return yargs.option('select', {
        type: 'string',
        describe: 'Select the subset of the returned json document (e.g., --selected=projects)',
    });
}
function withPlainOption(yargs) {
    return yargs.option('plain', {
        describe: 'Produces a plain output for affected:apps and affected:libs',
    });
}
function withAffectedOptions(yargs) {
    return yargs
        .option('files', {
        describe: 'Change the way Nx is calculating the affected command by providing directly changed files, list of files delimited by commas',
        type: 'array',
        requiresArg: true,
        coerce: parseCSV,
    })
        .option('uncommitted', {
        describe: 'Uncommitted changes',
        type: 'boolean',
        default: undefined,
    })
        .option('untracked', {
        describe: 'Untracked changes',
        type: 'boolean',
        default: undefined,
    })
        .option('all', {
        describe: 'All projects',
        type: 'boolean',
        default: undefined,
    })
        .option('base', {
        describe: 'Base of the current branch (usually main)',
        type: 'string',
        requiresArg: true,
    })
        .option('head', {
        describe: 'Latest commit of the current branch (usually HEAD)',
        type: 'string',
        requiresArg: true,
    })
        .group(['base'], 'Run command using --base=[SHA1] (affected by the committed, uncommitted and untracked changes):')
        .group(['base', 'head'], 'or using --base=[SHA1] --head=[SHA2] (affected by the committed changes):')
        .group(['files', 'uncommitted', 'untracked'], 'or using:')
        .implies('head', 'base')
        .option('exclude', {
        describe: 'Exclude certain projects from being processed',
        type: 'array',
        coerce: parseCSV,
        default: [],
    })
        .options('runner', {
        describe: 'This is the name of the tasks runner configured in nx.json',
        type: 'string',
    })
        .options('skip-nx-cache', {
        describe: 'Rerun the tasks even when the results are available in the cache',
        type: 'boolean',
        default: false,
    })
        .options('configuration', {
        describe: 'This is the configuration to use when performing tasks on projects',
        type: 'string',
    })
        .options('only-failed', {
        deprecated: 'The command to rerun failed projects will appear if projects fail. This now does nothing and will be removed in v15.',
        describe: 'Isolate projects which previously failed',
        type: 'boolean',
        default: false,
    })
        .option('verbose', {
        describe: 'Print additional error stack trace on failure',
    })
        .conflicts({
        files: ['uncommitted', 'untracked', 'base', 'head', 'all'],
        untracked: ['uncommitted', 'files', 'base', 'head', 'all'],
        uncommitted: ['files', 'untracked', 'base', 'head', 'all'],
        all: ['files', 'untracked', 'uncommitted', 'base', 'head'],
    });
}
function withRunManyOptions(yargs) {
    return yargs
        .option('projects', {
        describe: 'Projects to run (comma delimited)',
        type: 'string',
    })
        .option('all', {
        describe: 'Run the target on all projects in the workspace',
        type: 'boolean',
        default: undefined,
    })
        .check(({ all, projects }) => {
        if ((all && projects) || (!all && !projects))
            throw new Error('You must provide either --all or --projects');
        return true;
    })
        .options('runner', {
        describe: 'Override the tasks runner in `nx.json`',
        type: 'string',
    })
        .options('skip-nx-cache', {
        describe: 'Rerun the tasks even when the results are available in the cache',
        type: 'boolean',
        default: false,
    })
        .options('configuration', {
        describe: 'This is the configuration to use when performing tasks on projects',
        type: 'string',
    })
        .options('with-deps', {
        describe: 'Include dependencies of specified projects when computing what to run',
        type: 'boolean',
        default: false,
        deprecated: 'Configure target dependencies instead. It will be removed in v14.',
    })
        .options('only-failed', {
        deprecated: 'The command to rerun failed projects will appear if projects fail. This now does nothing and will be removed in v15.',
        describe: 'Only run the target on projects which previously failed',
        type: 'boolean',
        default: false,
    })
        .option('exclude', {
        describe: 'Exclude certain projects from being processed',
        type: 'array',
        coerce: parseCSV,
        default: [],
    })
        .option('verbose', {
        describe: 'Print additional error stack trace on failure',
    })
        .conflicts({
        all: 'projects',
    });
}
function withDepGraphOptions(yargs) {
    return yargs
        .option('file', {
        describe: 'Output file (e.g. --file=output.json or --file=dep-graph.html)',
        type: 'string',
    })
        .option('focus', {
        describe: 'Use to show the project graph for a particular project and every node that is either an ancestor or a descendant.',
        type: 'string',
    })
        .option('exclude', {
        describe: 'List of projects delimited by commas to exclude from the project graph.',
        type: 'array',
        coerce: parseCSV,
    })
        .option('groupByFolder', {
        describe: 'Group projects by folder in the project graph',
        type: 'boolean',
    })
        .option('host', {
        describe: 'Bind the project graph server to a specific ip address.',
        type: 'string',
    })
        .option('port', {
        describe: 'Bind the project graph server to a specific port.',
        type: 'number',
    })
        .option('watch', {
        describe: 'Watch for changes to project graph and update in-browser',
        type: 'boolean',
        default: false,
    })
        .option('open', {
        describe: 'Open the project graph in the browser.',
        type: 'boolean',
        default: true,
    });
}
function parseCSV(args) {
    return args
        .map((arg) => arg.split(','))
        .reduce((acc, value) => {
        return [...acc, ...value];
    }, []);
}
function withParallel(yargs) {
    return yargs.option('parallel', {
        describe: 'Max number of parallel processes [default is 3]',
        type: 'string',
    });
}
function withTarget(yargs) {
    return yargs.option('target', {
        describe: 'Task to run for affected projects',
        type: 'string',
        requiresArg: true,
        demandOption: true,
        global: false,
    });
}
function nxCliPath() {
    try {
        const packageManager = (0, devkit_1.getPackageManagerCommand)();
        const { dirSync } = require('tmp');
        const tmpDir = dirSync().name;
        (0, devkit_1.writeJsonFile)(path.join(tmpDir, 'package.json'), {
            dependencies: {
                nx: 'latest',
            },
            license: 'MIT',
        });
        (0, child_process_1.execSync)(packageManager.install, {
            cwd: tmpDir,
            stdio: ['ignore', 'ignore', 'ignore'],
        });
        // Set NODE_PATH so that these modules can be used for module resolution
        addToNodePath(path.join(tmpDir, 'node_modules'));
        addToNodePath(path.join(app_root_1.appRootPath, 'node_modules'));
        return path.join(tmpDir, `node_modules`, '.bin', 'nx');
    }
    catch (e) {
        console.error('Failed to install the latest version of the migration script. Using the current version.');
        if (process.env.NX_VERBOSE_LOGGING) {
            console.error(e);
        }
        return null;
    }
}
function addToNodePath(dir) {
    // NODE_PATH is a delimited list of paths.
    // The delimiter is different for windows.
    const delimiter = require('os').platform() === 'win32' ? ';' : ':';
    const paths = process.env.NODE_PATH
        ? process.env.NODE_PATH.split(delimiter)
        : [];
    // Add the tmp path
    paths.push(dir);
    // Update the env variable.
    process.env.NODE_PATH = paths.join(delimiter);
}
//# sourceMappingURL=nx-commands.js.map