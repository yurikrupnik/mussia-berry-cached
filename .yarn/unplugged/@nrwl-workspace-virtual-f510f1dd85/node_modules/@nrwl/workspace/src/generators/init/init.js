"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initSchematic = exports.initGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const fs_1 = require("fs");
const path_1 = require("path");
const prettier_1 = require("../../utilities/prettier");
const default_base_1 = require("../../utilities/default-base");
const versions_1 = require("../../utils/versions");
const workspace_1 = require("../workspace/workspace");
const typescript_1 = require("../../utilities/typescript");
function updatePackageJson(tree) {
    (0, devkit_1.updateJson)(tree, 'package.json', (packageJson) => {
        var _a, _b;
        packageJson.scripts = packageJson.scripts || {};
        packageJson.scripts = Object.assign(Object.assign({}, packageJson.scripts), { nx: 'nx', 'affected:apps': 'nx affected:apps', 'affected:libs': 'nx affected:libs', 'affected:build': 'nx affected:build', 'affected:e2e': 'nx affected:e2e', 'affected:test': 'nx affected:test', 'affected:lint': 'nx affected:lint', 'affected:graph': 'nx affected:graph', affected: 'nx affected', format: 'nx format:write', 'format:write': 'nx format:write', 'format:check': 'nx format:check', update: 'ng update @nrwl/workspace', 'update:check': 'ng update', lint: 'nx workspace-lint && ng lint', graph: 'nx graph', 'workspace-schematic': 'nx workspace-schematic', help: 'nx help' });
        packageJson.devDependencies = (_a = packageJson.devDependencies) !== null && _a !== void 0 ? _a : {};
        packageJson.dependencies = (_b = packageJson.dependencies) !== null && _b !== void 0 ? _b : {};
        if (!packageJson.dependencies['@nrwl/angular']) {
            packageJson.dependencies['@nrwl/angular'] = versions_1.nxVersion;
        }
        delete packageJson.dependencies['@nrwl/workspace'];
        if (!packageJson.devDependencies['@nrwl/workspace']) {
            packageJson.devDependencies['@nrwl/workspace'] = versions_1.nxVersion;
        }
        if (!packageJson.devDependencies['@angular/cli']) {
            packageJson.devDependencies['@angular/cli'] = versions_1.angularCliVersion;
        }
        if (!packageJson.devDependencies['prettier']) {
            packageJson.devDependencies['prettier'] = versions_1.prettierVersion;
        }
        return packageJson;
    });
}
function convertPath(name, originalPath) {
    return `apps/${name}/${originalPath}`;
}
function updateAngularCLIJson(host, options) {
    var _a;
    const workspaceConfig = (0, devkit_1.readWorkspaceConfiguration)(host);
    const appName = workspaceConfig.defaultProject;
    const e2eName = `${appName}-e2e`;
    const e2eRoot = (0, devkit_1.joinPathFragments)('apps', e2eName);
    delete workspaceConfig.newProjectRoot;
    const defaultProject = (0, devkit_1.readProjectConfiguration)(host, appName);
    const oldSourceRoot = defaultProject.sourceRoot;
    const newRoot = (0, devkit_1.joinPathFragments)('apps', appName);
    defaultProject.root = newRoot;
    defaultProject.sourceRoot = (0, devkit_1.joinPathFragments)(newRoot, 'src');
    function convertBuildOptions(buildOptions) {
        buildOptions.outputPath =
            buildOptions.outputPath &&
                (0, devkit_1.joinPathFragments)((0, devkit_1.normalizePath)('dist'), 'apps', appName);
        buildOptions.index =
            buildOptions.index && convertAsset(buildOptions.index);
        buildOptions.main =
            buildOptions.main && convertAsset(buildOptions.main);
        buildOptions.polyfills =
            buildOptions.polyfills && convertAsset(buildOptions.polyfills);
        buildOptions.tsConfig =
            buildOptions.tsConfig && (0, devkit_1.joinPathFragments)(newRoot, 'tsconfig.app.json');
        buildOptions.assets =
            buildOptions.assets && buildOptions.assets.map(convertAsset);
        buildOptions.styles =
            buildOptions.styles && buildOptions.styles.map(convertAsset);
        buildOptions.scripts =
            buildOptions.scripts && buildOptions.scripts.map(convertAsset);
        buildOptions.fileReplacements =
            buildOptions.fileReplacements &&
                buildOptions.fileReplacements.map((replacement) => ({
                    replace: convertAsset(replacement.replace),
                    with: convertAsset(replacement.with),
                }));
    }
    convertBuildOptions(defaultProject.targets.build.options);
    Object.values(defaultProject.targets.build.configurations).forEach((config) => convertBuildOptions(config));
    if (defaultProject.targets.test) {
        const testOptions = defaultProject.targets.test.options;
        testOptions.main = testOptions.main && convertAsset(testOptions.main);
        testOptions.polyfills =
            testOptions.polyfills && convertAsset(testOptions.polyfills);
        testOptions.tsConfig = (0, devkit_1.joinPathFragments)(newRoot, 'tsconfig.spec.json');
        testOptions.karmaConfig = (0, devkit_1.joinPathFragments)(newRoot, 'karma.conf.js');
        testOptions.assets =
            testOptions.assets && testOptions.assets.map(convertAsset);
        testOptions.styles =
            testOptions.styles && testOptions.styles.map(convertAsset);
        testOptions.scripts =
            testOptions.scripts && testOptions.scripts.map(convertAsset);
    }
    const lintTarget = defaultProject.targets.lint;
    if (lintTarget) {
        lintTarget.options.tsConfig = [
            (0, devkit_1.joinPathFragments)(newRoot, 'tsconfig.app.json'),
            (0, devkit_1.joinPathFragments)(newRoot, 'tsconfig.spec.json'),
        ];
    }
    function convertServerOptions(serverOptions) {
        serverOptions.outputPath =
            serverOptions.outputPath &&
                (0, devkit_1.joinPathFragments)((0, devkit_1.normalizePath)('dist'), 'apps', `${options.name}-server`);
        serverOptions.main = serverOptions.main && convertAsset(serverOptions.main);
        serverOptions.tsConfig =
            serverOptions.tsConfig &&
                (0, devkit_1.joinPathFragments)((0, devkit_1.normalizePath)('apps'), appName, 'tsconfig.server.json');
        serverOptions.fileReplacements =
            serverOptions.fileReplacements &&
                serverOptions.fileReplacements.map((replacement) => ({
                    replace: convertAsset(replacement.replace),
                    with: convertAsset(replacement.with),
                }));
    }
    if (defaultProject.targets.server) {
        const serverOptions = defaultProject.targets.server.options;
        convertServerOptions(serverOptions);
        Object.values(defaultProject.targets.server.configurations).forEach((config) => convertServerOptions(config));
    }
    if (defaultProject.targets.e2e) {
        const lintTargetOptions = lintTarget ? lintTarget.options : {};
        if (isProtractorE2eProject(defaultProject)) {
            (0, devkit_1.addProjectConfiguration)(host, e2eName, {
                root: e2eRoot,
                projectType: 'application',
                targets: {
                    e2e: Object.assign(Object.assign({}, defaultProject.targets.e2e), { options: Object.assign(Object.assign({}, defaultProject.targets.e2e.options), { protractorConfig: (0, devkit_1.joinPathFragments)(e2eRoot, 'protractor.conf.js') }) }),
                    lint: {
                        executor: '@angular-devkit/build-angular:tslint',
                        options: Object.assign(Object.assign({}, lintTargetOptions), { tsConfig: (0, devkit_1.joinPathFragments)(e2eRoot, 'tsconfig.json') }),
                    },
                },
                implicitDependencies: [appName],
                tags: [],
            });
        }
        else if (isCypressE2eProject(defaultProject)) {
            const cypressConfig = (0, devkit_1.joinPathFragments)(e2eRoot, (0, path_1.basename)((_a = getCypressConfigFile(defaultProject)) !== null && _a !== void 0 ? _a : 'cypress.json'));
            const e2eProjectConfig = {
                root: e2eRoot,
                sourceRoot: (0, devkit_1.joinPathFragments)(e2eRoot, 'src'),
                projectType: 'application',
                targets: {
                    e2e: updateE2eCypressTarget(defaultProject.targets.e2e, cypressConfig),
                },
                implicitDependencies: [appName],
                tags: [],
            };
            if (defaultProject.targets['cypress-run']) {
                e2eProjectConfig.targets['cypress-run'] = updateE2eCypressTarget(defaultProject.targets['cypress-run'], cypressConfig);
            }
            if (defaultProject.targets['cypress-open']) {
                e2eProjectConfig.targets['cypress-open'] = updateE2eCypressTarget(defaultProject.targets['cypress-open'], cypressConfig);
            }
            (0, devkit_1.addProjectConfiguration)(host, e2eName, e2eProjectConfig);
            delete defaultProject.targets['cypress-run'];
            delete defaultProject.targets['cypress-open'];
        }
        delete defaultProject.targets.e2e;
    }
    (0, devkit_1.updateProjectConfiguration)(host, appName, defaultProject);
    workspaceConfig.cli = workspaceConfig.cli || {};
    if (!workspaceConfig.cli.defaultCollection) {
        workspaceConfig.cli.defaultCollection = '@nrwl/angular';
    }
    (0, devkit_1.updateWorkspaceConfiguration)(host, workspaceConfig);
    function convertAsset(asset) {
        if (typeof asset === 'string') {
            return asset.startsWith(oldSourceRoot)
                ? convertPath(appName, asset.replace(oldSourceRoot, 'src'))
                : asset;
        }
        else {
            return Object.assign(Object.assign({}, asset), { input: asset.input && asset.input.startsWith(oldSourceRoot)
                    ? convertPath(appName, asset.input.replace(oldSourceRoot, 'src'))
                    : asset.input });
        }
    }
}
function getCypressConfigFile(e2eProject) {
    let cypressConfig = 'cypress.json';
    const configFileOption = e2eProject.targets.e2e.options.configFile;
    if (configFileOption === false) {
        cypressConfig = undefined;
    }
    else if (typeof configFileOption === 'string') {
        cypressConfig = (0, path_1.basename)(configFileOption);
    }
    return cypressConfig;
}
function updateE2eCypressTarget(target, cypressConfig) {
    const updatedTarget = Object.assign(Object.assign({}, target), { executor: '@nrwl/cypress:cypress', options: Object.assign(Object.assign({}, target.options), { cypressConfig }) });
    delete updatedTarget.options.configFile;
    delete updatedTarget.options.tsConfig;
    if (updatedTarget.options.headless && updatedTarget.options.watch) {
        updatedTarget.options.headed = false;
    }
    else if (updatedTarget.options.headless === false &&
        !updatedTarget.options.watch) {
        updatedTarget.options.headed = true;
    }
    delete updatedTarget.options.headless;
    return updatedTarget;
}
function updateTsConfig(host) {
    (0, devkit_1.updateJson)(host, 'nx.json', (json) => {
        json.implicitDependencies['tsconfig.base.json'] = '*';
        return json;
    });
    (0, devkit_1.writeJson)(host, 'tsconfig.base.json', setUpCompilerOptions((0, devkit_1.readJson)(host, (0, typescript_1.getRootTsConfigPathInTree)(host))));
    if (host.exists('tsconfig.json')) {
        host.delete('tsconfig.json');
    }
}
function updateTsConfigsJson(host, options) {
    const app = (0, devkit_1.readProjectConfiguration)(host, options.name);
    const e2eProject = getE2eProject(host);
    const tsConfigPath = (0, typescript_1.getRootTsConfigPathInTree)(host);
    const appOffset = (0, devkit_1.offsetFromRoot)(app.root);
    (0, devkit_1.updateJson)(host, app.targets.build.options.tsConfig, (json) => {
        json.extends = `${appOffset}${tsConfigPath}`;
        json.compilerOptions = json.compilerOptions || {};
        json.compilerOptions.outDir = `${appOffset}dist/out-tsc`;
        return json;
    });
    if (app.targets.test) {
        (0, devkit_1.updateJson)(host, app.targets.test.options.tsConfig, (json) => {
            json.extends = `${appOffset}${tsConfigPath}`;
            json.compilerOptions = json.compilerOptions || {};
            json.compilerOptions.outDir = `${appOffset}dist/out-tsc`;
            return json;
        });
    }
    if (app.targets.server) {
        (0, devkit_1.updateJson)(host, app.targets.server.options.tsConfig, (json) => {
            json.extends = `${appOffset}${tsConfigPath}`;
            json.compilerOptions = json.compilerOptions || {};
            json.compilerOptions.outDir = `${appOffset}dist/out-tsc`;
            return json;
        });
    }
    if (!!e2eProject) {
        const tsConfig = isProtractorE2eProject(e2eProject)
            ? e2eProject.targets.lint.options.tsConfig
            : (0, devkit_1.joinPathFragments)(e2eProject.root, 'tsconfig.json');
        (0, devkit_1.updateJson)(host, tsConfig, (json) => {
            json.extends = `${(0, devkit_1.offsetFromRoot)(e2eProject.root)}${tsConfigPath}`;
            json.compilerOptions = Object.assign(Object.assign({}, json.compilerOptions), { outDir: `${(0, devkit_1.offsetFromRoot)(e2eProject.root)}dist/out-tsc` });
            return json;
        });
    }
}
function updateTsLint(host) {
    if (host.exists(`tslint.json`)) {
        (0, devkit_1.updateJson)(host, 'tslint.json', (tslintJson) => {
            [
                'no-trailing-whitespace',
                'one-line',
                'quotemark',
                'typedef-whitespace',
                'whitespace',
            ].forEach((key) => {
                tslintJson[key] = undefined;
            });
            tslintJson.rulesDirectory = tslintJson.rulesDirectory || [];
            tslintJson.rulesDirectory.push('node_modules/@nrwl/workspace/src/tslint');
            tslintJson.rules['nx-enforce-module-boundaries'] = [
                true,
                {
                    allow: [],
                    depConstraints: [{ sourceTag: '*', onlyDependOnLibsWithTags: ['*'] }],
                },
            ];
            return tslintJson;
        });
    }
}
function updateProjectTsLint(host, options) {
    const workspaceJson = (0, devkit_1.readJson)(host, (0, devkit_1.getWorkspacePath)(host));
    const app = workspaceJson.projects[options.name];
    const offset = '../../';
    if (host.exists(`${app.root}/tslint.json`)) {
        (0, devkit_1.updateJson)(host, `${app.root}/tslint.json`, (json) => {
            json.extends = `${offset}tslint.json`;
            return json;
        });
    }
}
function setUpCompilerOptions(tsconfig) {
    if (!tsconfig.compilerOptions.paths) {
        tsconfig.compilerOptions.paths = {};
    }
    tsconfig.compilerOptions.baseUrl = '.';
    tsconfig.compilerOptions.rootDir = '.';
    return tsconfig;
}
function moveOutOfSrc(tree, appName, filePath, required = true) {
    if (!filePath) {
        return;
    }
    const filename = !!filePath ? (0, path_1.basename)(filePath) : '';
    const from = filePath;
    const to = filename
        ? (0, devkit_1.joinPathFragments)('apps', appName, filename)
        : (0, devkit_1.joinPathFragments)('apps', appName);
    renameSyncInTree(tree, from, to, required);
}
function getE2eKey(host) {
    const projects = (0, devkit_1.getProjects)(host);
    for (const [projectName, project] of projects) {
        if (project.targets.e2e) {
            return projectName;
        }
    }
}
function getE2eProject(host) {
    const key = getE2eKey(host);
    if (key) {
        return (0, devkit_1.readProjectConfiguration)(host, key);
    }
    else {
        return null;
    }
}
function isCypressE2eProject(e2eProject) {
    return e2eProject.targets.e2e.executor === '@cypress/schematic:cypress';
}
function isProtractorE2eProject(e2eProject) {
    return (e2eProject.targets.e2e.executor ===
        '@angular-devkit/build-angular:protractor');
}
function moveExistingFiles(host, options) {
    const app = (0, devkit_1.readProjectConfiguration)(host, options.name);
    // it is not required to have a browserslist
    moveOutOfSrc(host, options.name, 'browserslist', false);
    moveOutOfSrc(host, options.name, '.browserslistrc', false);
    moveOutOfSrc(host, options.name, app.targets.build.options.tsConfig);
    if (app.targets.test) {
        moveOutOfSrc(host, options.name, app.targets.test.options.karmaConfig);
        moveOutOfSrc(host, options.name, app.targets.test.options.tsConfig);
    }
    else {
        // there could still be a karma.conf.js file in the root
        // so move to new location
        if (host.exists('karma.conf.js')) {
            console.info('No test configuration, but root Karma config file found');
            moveOutOfSrc(host, options.name, 'karma.conf.js');
        }
    }
    if (app.targets.server) {
        moveOutOfSrc(host, options.name, app.targets.server.options.tsConfig);
    }
    const oldAppSourceRoot = app.sourceRoot;
    const newAppSourceRoot = (0, devkit_1.joinPathFragments)('apps', options.name, 'src');
    renameDirSyncInTree(host, oldAppSourceRoot, newAppSourceRoot);
    moveE2eProjectFiles(host, app, options);
}
function moveE2eProjectFiles(tree, app, options) {
    const e2eProject = getE2eProject(tree);
    if (!e2eProject) {
        console.warn('No e2e project was migrated because there was none declared in angular.json.');
        return;
    }
    if (isProtractorE2eProject(e2eProject)) {
        const oldE2eRoot = (0, devkit_1.joinPathFragments)(app.root || '', 'e2e');
        const newE2eRoot = (0, devkit_1.joinPathFragments)('apps', `${getE2eKey(tree)}-e2e`);
        renameDirSyncInTree(tree, oldE2eRoot, newE2eRoot);
    }
    else if (isCypressE2eProject(e2eProject)) {
        const e2eProjectName = `${options.name}-e2e`;
        const configFile = getCypressConfigFile(e2eProject);
        const oldE2eRoot = 'cypress';
        const newE2eRoot = (0, devkit_1.joinPathFragments)('apps', e2eProjectName);
        if (configFile) {
            updateCypressConfigFilePaths(tree, configFile, oldE2eRoot, newE2eRoot);
            moveOutOfSrc(tree, e2eProjectName, configFile);
        }
        else {
            tree.write((0, devkit_1.joinPathFragments)('apps', e2eProjectName, 'cypress.json'), JSON.stringify({
                fileServerFolder: '.',
                fixturesFolder: './src/fixtures',
                integrationFolder: './src/integration',
                modifyObstructiveCode: false,
                supportFile: './src/support/index.ts',
                pluginsFile: './src/plugins/index.ts',
                video: true,
                videosFolder: `../../dist/cypress/${newE2eRoot}/videos`,
                screenshotsFolder: `../../dist/cypress/${newE2eRoot}/screenshots`,
                chromeWebSecurity: false,
            }));
        }
        moveOutOfSrc(tree, e2eProjectName, `${oldE2eRoot}/tsconfig.json`);
        renameDirSyncInTree(tree, oldE2eRoot, (0, devkit_1.joinPathFragments)('apps', e2eProjectName, 'src'));
    }
}
function updateCypressConfigFilePaths(tree, configFile, oldE2eRoot, newE2eRoot) {
    const srcFoldersAndFiles = [
        'integrationFolder',
        'supportFile',
        'pluginsFile',
        'fixturesFolder',
    ];
    const distFolders = ['videosFolder', 'screenshotsFolder'];
    const stringOrArrayGlobs = ['ignoreTestFiles', 'testFiles'];
    const cypressConfig = (0, devkit_1.readJson)(tree, configFile);
    cypressConfig.fileServerFolder = '.';
    srcFoldersAndFiles.forEach((folderOrFile) => {
        if (cypressConfig[folderOrFile]) {
            cypressConfig[folderOrFile] = `./src/${(0, path_1.relative)(oldE2eRoot, cypressConfig[folderOrFile])}`;
        }
    });
    distFolders.forEach((folder) => {
        if (cypressConfig[folder]) {
            cypressConfig[folder] = `../../dist/cypress/${newE2eRoot}/${(0, path_1.relative)(oldE2eRoot, cypressConfig[folder])}`;
        }
    });
    stringOrArrayGlobs.forEach((stringOrArrayGlob) => {
        if (!cypressConfig[stringOrArrayGlob]) {
            return;
        }
        if (Array.isArray(cypressConfig[stringOrArrayGlob])) {
            cypressConfig[stringOrArrayGlob] = cypressConfig[stringOrArrayGlob].map((glob) => replaceCypressGlobConfig(glob, oldE2eRoot));
        }
        else {
            cypressConfig[stringOrArrayGlob] = replaceCypressGlobConfig(cypressConfig[stringOrArrayGlob], oldE2eRoot);
        }
    });
    (0, devkit_1.writeJson)(tree, configFile, cypressConfig);
}
function replaceCypressGlobConfig(globPattern, oldE2eRoot) {
    return globPattern.replace(new RegExp(`^(\\.\\/|\\/)?${oldE2eRoot}\\/`), './src/');
}
function createAdditionalFiles(host, options) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const nxJson = {
            npmScope: options.npmScope,
            affected: {
                defaultBase: options.defaultBase
                    ? `${options.defaultBase}`
                    : (0, default_base_1.deduceDefaultBase)(),
            },
            implicitDependencies: {
                'angular.json': '*',
                'package.json': '*',
                'tslint.json': '*',
                '.eslintrc.json': '*',
                'nx.json': '*',
            },
        };
        (0, devkit_1.writeJson)(host, 'nx.json', nxJson);
        host.write('libs/.gitkeep', '');
        const recommendations = [
            'nrwl.angular-console',
            'angular.ng-template',
            'dbaeumer.vscode-eslint',
            'esbenp.prettier-vscode',
        ];
        if (host.exists('.vscode/extensions.json')) {
            (0, devkit_1.updateJson)(host, '.vscode/extensions.json', (json) => {
                json.recommendations = json.recommendations || [];
                recommendations.forEach((extension) => {
                    if (!json.recommendations.includes(extension)) {
                        json.recommendations.push(extension);
                    }
                });
                return json;
            });
        }
        else {
            (0, devkit_1.writeJson)(host, '.vscode/extensions.json', {
                recommendations,
            });
        }
        // if the user does not already have a prettier configuration
        // of any kind, create one
        const existingPrettierConfig = yield (0, prettier_1.resolveUserExistingPrettierConfig)();
        if (!existingPrettierConfig) {
            (0, devkit_1.writeJson)(host, '.prettierrc', workspace_1.DEFAULT_NRWL_PRETTIER_CONFIG);
        }
    });
}
function checkCanConvertToWorkspace(host) {
    try {
        if (!host.exists('package.json')) {
            throw new Error('Cannot find package.json');
        }
        if (!host.exists('angular.json')) {
            throw new Error('Cannot find angular.json');
        }
        // TODO: This restriction should be lited
        const workspaceJson = (0, devkit_1.readJson)(host, 'angular.json');
        const hasLibraries = Object.keys(workspaceJson.projects).find((project) => workspaceJson.projects[project].projectType &&
            workspaceJson.projects[project].projectType !== 'application');
        if (Object.keys(workspaceJson.projects).length > 2 || hasLibraries) {
            throw new Error('Can only convert projects with one app');
        }
        const e2eKey = getE2eKey(host);
        const e2eApp = getE2eProject(host);
        if (!e2eApp) {
            return;
        }
        if (isProtractorE2eProject(e2eApp)) {
            if (host.exists(e2eApp.targets.e2e.options.protractorConfig)) {
                return;
            }
            console.info(`Make sure the "${e2eKey}.architect.e2e.options.protractorConfig" is valid or the "${e2eKey}" project is removed from "angular.json".`);
            throw new Error(`An e2e project with Protractor was found but "${e2eApp.targets.e2e.options.protractorConfig}" could not be found.`);
        }
        if (isCypressE2eProject(e2eApp)) {
            const configFile = getCypressConfigFile(e2eApp);
            if (configFile && !host.exists(configFile)) {
                throw new Error(`An e2e project with Cypress was found but "${configFile}" could not be found.`);
            }
            if (!host.exists('cypress')) {
                throw new Error(`An e2e project with Cypress was found but the "cypress" directory could not be found.`);
            }
            return;
        }
        throw new Error(`An e2e project was found but it's using an unsupported executor "${e2eApp.targets.e2e.executor}".`);
    }
    catch (e) {
        console.error(e.message);
        console.error('Your workspace could not be converted into an Nx Workspace because of the above error.');
        throw e;
    }
}
function createNxJson(host, options) {
    var _a;
    const { newProjectRoot = '' } = (0, devkit_1.readJson)(host, 'angular.json');
    (0, devkit_1.writeJson)(host, 'nx.json', {
        npmScope: options.npmScope,
        affected: {
            defaultBase: (_a = options.defaultBase) !== null && _a !== void 0 ? _a : (0, default_base_1.deduceDefaultBase)(),
        },
        implicitDependencies: {
            'package.json': {
                dependencies: '*',
                devDependencies: '*',
            },
            '.eslintrc.json': '*',
        },
        tasksRunnerOptions: {
            default: {
                runner: '@nrwl/workspace/tasks-runners/default',
                options: {
                    cacheableOperations: ['build', 'lint', 'test', 'e2e'],
                },
            },
        },
        targetDependencies: {
            build: [
                {
                    target: 'build',
                    projects: 'dependencies',
                },
            ],
        },
        workspaceLayout: { appsDir: newProjectRoot, libsDir: newProjectRoot },
    });
}
function decorateAngularClI(host) {
    const decorateCli = (0, fs_1.readFileSync)((0, devkit_1.joinPathFragments)(__dirname, '..', 'utils', 'decorate-angular-cli.js__tmpl__')).toString();
    host.write('decorate-angular-cli.js', decorateCli);
    (0, devkit_1.updateJson)(host, 'package.json', (json) => {
        if (json.scripts &&
            json.scripts.postinstall &&
            !json.scripts.postinstall.includes('decorate-angular-cli.js')) {
            // if exists, add execution of this script
            json.scripts.postinstall += ' && node ./decorate-angular-cli.js';
        }
        else {
            if (!json.scripts)
                json.scripts = {};
            // if doesn't exist, set to execute this script
            json.scripts.postinstall = 'node ./decorate-angular-cli.js';
        }
        if (json.scripts.ng) {
            json.scripts.ng = 'nx';
        }
        return json;
    });
}
function addFiles(host) {
    (0, devkit_1.generateFiles)(host, (0, devkit_1.joinPathFragments)(__dirname, './files/root'), '.', {
        tmpl: '',
        dot: '.',
        rootTsConfigPath: (0, typescript_1.getRootTsConfigPathInTree)(host),
    });
    if (!host.exists('.prettierignore')) {
        (0, devkit_1.generateFiles)(host, (0, devkit_1.joinPathFragments)(__dirname, './files/prettier'), '.', {
            tmpl: '',
            dot: '.',
        });
    }
}
function renameSyncInTree(tree, from, to, required) {
    if (!tree.exists(from)) {
        if (required) {
            console.warn(`Path: ${from} does not exist`);
        }
    }
    else if (tree.exists(to)) {
        if (required) {
            console.warn(`Path: ${to} already exists`);
        }
    }
    else {
        const contents = tree.read(from);
        tree.write(to, contents);
        tree.delete(from);
    }
}
function renameDirSyncInTree(tree, from, to) {
    (0, devkit_1.visitNotIgnoredFiles)(tree, from, (file) => {
        renameSyncInTree(tree, file, file.replace(from, to), true);
    });
}
function resolveNpmScope(tree, options) {
    var _a;
    let npmScope = (_a = options.npmScope) !== null && _a !== void 0 ? _a : options.name;
    if (npmScope) {
        return (0, devkit_1.names)(npmScope).fileName;
    }
    // try get the scope from any library that have one
    const projects = (0, devkit_1.getProjects)(tree);
    for (const [, project] of projects) {
        if (project.projectType === 'application' ||
            !tree.exists((0, devkit_1.joinPathFragments)(project.root, 'package.json'))) {
            continue;
        }
        const { name } = (0, devkit_1.readJson)(tree, (0, devkit_1.joinPathFragments)(project.root, 'package.json'));
        if (name.startsWith('@')) {
            return name.split('/')[0].substring(1);
        }
    }
    // use the name (scope if exists) in the root package.json
    const { name } = (0, devkit_1.readJson)(tree, 'package.json');
    return name.startsWith('@') ? name.split('/')[0].substring(1) : name;
}
function initGenerator(tree, schema) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const options = Object.assign(Object.assign({}, schema), { npmScope: resolveNpmScope(tree, schema) });
        if (schema.preserveAngularCliLayout) {
            (0, devkit_1.updateJson)(tree, 'package.json', (json) => {
                var _a;
                (_a = json.dependencies) === null || _a === void 0 ? true : delete _a['@nrwl/workspace'];
                json.devDependencies = Object.assign(Object.assign({}, json.devDependencies), { '@nrwl/workspace': versions_1.nxVersion });
                return json;
            });
            createNxJson(tree, options);
            decorateAngularClI(tree);
        }
        else {
            checkCanConvertToWorkspace(tree);
            moveExistingFiles(tree, options);
            addFiles(tree);
            yield createAdditionalFiles(tree, options);
            updatePackageJson(tree);
            updateAngularCLIJson(tree, options);
            updateTsLint(tree);
            updateProjectTsLint(tree, options);
            updateTsConfig(tree);
            updateTsConfigsJson(tree, options);
            decorateAngularClI(tree);
            yield (0, devkit_1.formatFiles)(tree);
        }
        if (!schema.skipInstall) {
            return () => {
                (0, devkit_1.installPackagesTask)(tree);
            };
        }
    });
}
exports.initGenerator = initGenerator;
exports.initSchematic = (0, devkit_1.convertNxGenerator)(initGenerator);
exports.default = initGenerator;
//# sourceMappingURL=init.js.map